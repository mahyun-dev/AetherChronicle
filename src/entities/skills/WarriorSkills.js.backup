import { Skill } from '../Skill.js';

/**
 * WarriorSkills - ì „ì‚¬ ìŠ¤í‚¬ë“¤
 * ëŒì§„ ë² ê¸°, ë°©ì–´ ìì„¸, íšŒì „ ë² ê¸°, íŒŒë©¸ì˜ ì¼ê²©
 */

/**
 * DashSkill - ëŒì§„ ìŠ¤í‚¬ (ëŒì§„ ë² ê¸°)
 */
export class DashSkill extends Skill {
  execute(caster, target) {
    const scene = caster.scene;

    // ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ëŒì§„
    const pointer = scene.input.activePointer;
    const worldPoint = scene.cameras.main.getWorldPoint(pointer.x, pointer.y);
    const angle = Phaser.Math.Angle.Between(caster.x, caster.y, worldPoint.x, worldPoint.y);

    const dashDistance = this.range;
    const targetX = caster.x + Math.cos(angle) * dashDistance;
    const targetY = caster.y + Math.sin(angle) * dashDistance;

    // ë¬´ì  ìƒíƒœ
    caster.isInvincible = true;

    // ë‹¤ì¤‘ ì”ìƒ íš¨ê³¼ - ë” ê°•ë ¥í•˜ê²Œ
    const trailCount = 8;
    for (let i = 0; i < trailCount; i++) {
      scene.time.delayedCall(i * 25, () => {
        const trail = scene.add.rectangle(caster.x, caster.y, 32, 32, 0xFFD700, 0.7 - (i * 0.08));
        trail.setDepth(99);
        scene.tweens.add({
          targets: trail,
          alpha: 0,
          scale: 1.2,
          duration: 150,
          onComplete: () => trail.destroy()
        });
      });
    }

    // ëŒì§„ ì‹œì‘ ì¶©ê²©íŒŒ
    const startShockwave = scene.add.circle(caster.x, caster.y, 20, 0xFFFFFF, 0.8);
    startShockwave.setDepth(100);
    scene.tweens.add({
      targets: startShockwave,
      scale: 3,
      alpha: 0,
      duration: 200,
      onComplete: () => startShockwave.destroy()
    });

    // ëŒì§„ ì¤‘ ê²½ë¡œìƒ í”¼í•´ë¥¼ ìœ„í•œ ë³€ìˆ˜ë“¤
    const baseDamage = Math.floor(caster.stats.attack * this.damageMultiplier + this.damage);
    const comboMultiplier = caster.getComboMultiplier ? caster.getComboMultiplier() : 1.0;
    const totalDamage = Math.floor(baseDamage * comboMultiplier);
    const hitMonsters = new Set(); // ì¤‘ë³µ í”¼í•´ ë°©ì§€

    // ëŒì§„ íŠ¸ìœˆ
    scene.tweens.add({
      targets: caster,
      x: targetX,
      y: targetY,
      duration: 200,
      onUpdate: (tween, target) => {
        // ëŒì§„ ì¤‘ ê²½ë¡œìƒ ì  ì²´í¬ (ë§¤ í”„ë ˆì„)
        const monsters = scene.monsters.getChildren();
        monsters.forEach(monster => {
          if (hitMonsters.has(monster) || monster.isDead) return;

          const distance = Phaser.Math.Distance.Between(caster.x, caster.y, monster.x, monster.y);
          if (distance <= 60) { // ê²½ë¡œìƒ ë²”ìœ„
            hitMonsters.add(monster);

            const result = monster.takeDamage(totalDamage, caster);
            scene.showDamageText(monster.x, monster.y - 30, result.damage, result.isCrit, result.isEvaded);

            // ì½¤ë³´ ì¦ê°€
            if (!result.isEvaded && caster.increaseCombo) {
              caster.increaseCombo();
            }

            // ë„‰ë°± ì ìš©
            if (!result.isEvaded && this.knockbackPower > 0) {
              monster.applyKnockback(this.knockbackPower, 300, caster);
            }
          }
        });
      },
      onComplete: () => {
        caster.isInvincible = false;

        // ë„ì°© ì¶©ê²©íŒŒ íš¨ê³¼
        const endShockwave = scene.add.circle(targetX, targetY, 30, 0xFFD700, 0.8);
        endShockwave.setDepth(100);
        scene.tweens.add({
          targets: endShockwave,
          scale: 4,
          alpha: 0,
          duration: 300,
          onComplete: () => endShockwave.destroy()
        });

        // ë„ì°© ì§€ì  ë¨¼ì§€ íš¨ê³¼
        for (let i = 0; i < 12; i++) {
          const dustAngle = (i / 12) * Math.PI * 2;
          const dustDistance = 40;
          const dust = scene.add.circle(
            targetX + Math.cos(dustAngle) * dustDistance,
            targetY + Math.sin(dustAngle) * dustDistance,
            4, 0x8B4513, 0.6
          );
          dust.setDepth(98);

          scene.tweens.add({
            targets: dust,
            x: targetX + Math.cos(dustAngle) * (dustDistance + 30),
            y: targetY + Math.sin(dustAngle) * (dustDistance + 30),
            alpha: 0,
            duration: 400,
            onComplete: () => dust.destroy()
          });
        }
      }
    });
  }

/**
 * BuffSkill - ë²„í”„ ìŠ¤í‚¬ (ë°©ì–´ ìì„¸)
 */
export class BuffSkill extends Skill {
  execute(caster, target) {
    const scene = caster.scene;

    // ë°©ì–´ ìì„¸ ìŠ¤í‚¬ì¸ ê²½ìš° (warrior_skill_2)
    if (this.id === 'warrior_skill_2') {
      this.executeDefensiveStance(scene, caster);
    } else {
      // ì¼ë°˜ ë²„í”„ ìŠ¤í‚¬
      this.executeGenericBuff(scene, caster);
    }
  }

  executeDefensiveStance(scene, caster) {
    // ë°©ì–´ ìì„¸: ë°©ì–´ë§‰ ìƒì„± + ê°•í™” íš¨ê³¼
    const shieldColor = 0x4444FF;

    // ì¤‘ì•™ ë°©ì–´ë§‰
    const shield = scene.add.circle(caster.x, caster.y, 50, shieldColor, 0.4);
    shield.setDepth(150);

    // ë°©ì–´ë§‰ í…Œë‘ë¦¬ íš¨ê³¼
    const shieldBorder = scene.add.circle(caster.x, caster.y, 55, shieldColor, 0.2);
    shieldBorder.setDepth(149);

    // ë°©ì–´ë§‰ íŒŒí‹°í´
    const particles = [];
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const distance = 45;
      const particle = scene.add.circle(
        caster.x + Math.cos(angle) * distance,
        caster.y + Math.sin(angle) * distance,
        3, shieldColor, 0.8
      );
      particle.setDepth(151);
      particles.push(particle);

      // íŒŒí‹°í´ íšŒì „ ì• ë‹ˆë©”ì´ì…˜
      scene.tweens.add({
        targets: particle,
        angle: 360,
        duration: 3000,
        repeat: -1
      });
    }

    // ë°©ì–´ë§‰ì´ í”Œë ˆì´ì–´ë¥¼ ë”°ë¼ë‹¤ë‹ˆê²Œ
    const shieldFollow = scene.time.addEvent({
      delay: 16,
      callback: () => {
        if (shield.active && caster.active) {
          shield.setPosition(caster.x, caster.y);
          shieldBorder.setPosition(caster.x, caster.y);

          // íŒŒí‹°í´ë“¤ë„ í•¨ê»˜ ì´ë™
          particles.forEach((particle, index) => {
            if (particle.active) {
              const angle = (index / 16) * Math.PI * 2;
              const distance = 45;
              particle.setPosition(
                caster.x + Math.cos(angle) * distance,
                caster.y + Math.sin(angle) * distance
              );
            }
          });
        }
      },
      loop: true
    });

    // ì›ë³¸ ìŠ¤íƒ¯ ì €ì¥
    const originalStats = {};

    // ë²„í”„/ë””ë²„í”„ ì ìš©
    this.effects.forEach(effectData => {
      if (effectData.type === 'buff' || effectData.type === 'debuff') {
        const stat = effectData.stat;

        // íŠ¹ìˆ˜ ì²˜ë¦¬: damageReduction
        if (stat === 'damageReduction') {
          if (!caster.damageReduction) caster.damageReduction = 0;
          originalStats[stat] = caster.damageReduction;
          caster.damageReduction = effectData.value;
          console.log(`ğŸ›¡ï¸ ë°›ëŠ” í”¼í•´ ${Math.floor(effectData.value * 100)}% ê°ì†Œ`);
        } else if (caster.stats[stat] !== undefined) {
          originalStats[stat] = caster.stats[stat];
          if (effectData.type === 'buff') {
            caster.stats[stat] = Math.floor(originalStats[stat] * effectData.value);
            console.log(`ğŸ’ª ${stat} ì¦ê°€: ${originalStats[stat]} â†’ ${caster.stats[stat]}`);
          } else {
            caster.stats[stat] = Math.floor(originalStats[stat] * effectData.value);
            console.log(`â¬‡ï¸ ${stat} ê°ì†Œ: ${originalStats[stat]} â†’ ${caster.stats[stat]}`);
          }
        }
      }
    });

    // ë²„í”„ ì¢…ë£Œ
    scene.time.delayedCall(this.duration, () => {
      shieldFollow.remove();

      // ì´í™íŠ¸ ì œê±°
      scene.tweens.add({
        targets: [shield, shieldBorder],
        alpha: 0,
        duration: 500,
        onComplete: () => {
          shield.destroy();
          shieldBorder.destroy();
        }
      });

      // íŒŒí‹°í´ ì œê±°
      particles.forEach(particle => {
        scene.tweens.add({
          targets: particle,
          alpha: 0,
          duration: 500,
          onComplete: () => particle.destroy()
        });
      });

      // ìŠ¤íƒ¯ ë³µêµ¬
      Object.keys(originalStats).forEach(stat => {
        if (stat === 'damageReduction') {
          caster.damageReduction = originalStats[stat];
        } else if (caster.stats[stat] !== undefined) {
          caster.stats[stat] = originalStats[stat];
        }
        console.log(`â° ${stat} ì›ë˜ëŒ€ë¡œ: ${originalStats[stat]}`);
      });
    });
  }

  executeGenericBuff(scene, caster) {
    // ì¼ë°˜ ë²„í”„ ìŠ¤í‚¬ (ê¸°ì¡´ ë¡œì§)
    const effectColor = 0xFF0000;
    const effect = scene.add.circle(caster.x, caster.y, 40, effectColor, 0.6);
    effect.setDepth(150);
    scene.tweens.add({
      targets: effect,
      alpha: 0,
      scale: 2,
      duration: 500,
      onComplete: () => effect.destroy()
    });

    // ë²„í”„ ì ìš©
    this.applyBuffEffects(caster);
  }

  applyBuffEffects(caster) {
    const scene = caster.scene;
    const effectColor = 0xFF0000;

    // ì›ë³¸ ìŠ¤íƒ¯ ì €ì¥
    const originalStats = {};

    // ë²„í”„/ë””ë²„í”„ ì ìš©
    this.effects.forEach(effectData => {
      if (effectData.type === 'buff' || effectData.type === 'debuff') {
        const stat = effectData.stat;

        // íŠ¹ìˆ˜ ì²˜ë¦¬: damageReduction
        if (stat === 'damageReduction') {
          if (!caster.damageReduction) caster.damageReduction = 0;
          originalStats[stat] = caster.damageReduction;
          caster.damageReduction = effectData.value;
          console.log(`ğŸ›¡ï¸ ë°›ëŠ” í”¼í•´ ${Math.floor(effectData.value * 100)}% ê°ì†Œ`);
        } else if (caster.stats[stat] !== undefined) {
          originalStats[stat] = caster.stats[stat];
          if (effectData.type === 'buff') {
            caster.stats[stat] = Math.floor(originalStats[stat] * effectData.value);
            console.log(`ğŸ’ª ${stat} ì¦ê°€: ${originalStats[stat]} â†’ ${caster.stats[stat]}`);
          } else {
            caster.stats[stat] = Math.floor(originalStats[stat] * effectData.value);
            console.log(`â¬‡ï¸ ${stat} ê°ì†Œ: ${originalStats[stat]} â†’ ${caster.stats[stat]}`);
          }
        }
      }
    });

    // ë²„í”„ ì•„ìš°ë¼ (ì§€ì† ì‹œê°„ ë™ì•ˆ)
    const aura = scene.add.circle(caster.x, caster.y, 50, effectColor, 0.2);
    aura.setDepth(1);

    // í”Œë ˆì´ì–´ë¥¼ ë”°ë¼ë‹¤ë‹ˆëŠ” aura
    const auraFollow = scene.time.addEvent({
      delay: 16,
      callback: () => {
        if (aura.active && caster.active) {
          aura.setPosition(caster.x, caster.y);
        }
      },
      loop: true
    });

    // ë²„í”„ ì¢…ë£Œ
    scene.time.delayedCall(this.duration, () => {
      // ìŠ¤íƒ¯ ë³µêµ¬
      Object.keys(originalStats).forEach(stat => {
        if (stat === 'damageReduction') {
          caster.damageReduction = originalStats[stat];
        } else if (caster.stats[stat] !== undefined) {
          caster.stats[stat] = originalStats[stat];
          console.log(`â° ${stat} ì›ë˜ëŒ€ë¡œ: ${originalStats[stat]}`);
        }
      });

      // ì•„ìš°ë¼ ì œê±°
      if (aura.active) {
        aura.destroy();
      }
      auraFollow.destroy();
    });
  }
}

/**
 * AOESkill - ê´‘ì—­ ìŠ¤í‚¬ (íšŒì „ ë² ê¸°)
 */
export class AOESkill extends Skill {
  execute(caster, target) {
    const scene = caster.scene;
    const centerX = caster.x;
    const centerY = caster.y;

    // íšŒì „ ë² ê¸° ìŠ¤í‚¬ì¸ ê²½ìš° (warrior_skill_3)
    if (this.id === 'warrior_skill_3') {
      this.executeWhirlingSlash(scene, caster, centerX, centerY);
    } else {
      // ì¼ë°˜ AOE ìŠ¤í‚¬
      this.executeGenericAOE(scene, caster, centerX, centerY);
    }
  }

  executeWhirlingSlash(scene, caster, centerX, centerY) {
    // íšŒì „ ë² ê¸°: íšŒì „í•˜ëŠ” ê²€ê¸° íš¨ê³¼
    const slashCount = 6;
    const slashColor = 0xFFD700;

    // íšŒì „í•˜ëŠ” ê²€ê¸°ë“¤ ìƒì„±
    for (let i = 0; i < slashCount; i++) {
      scene.time.delayedCall(i * 80, () => {
        const angle = (i / slashCount) * Math.PI * 2;

        // ê²€ê¸° ì„ 
        const slash = scene.add.rectangle(
          centerX + Math.cos(angle) * (this.radius * 0.7),
          centerY + Math.sin(angle) * (this.radius * 0.7),
          this.radius * 0.8, 8, slashColor, 0.8
        );
        slash.setRotation(angle);
        slash.setDepth(100);

        // ê²€ê¸° íŒŒí‹°í´
        for (let j = 0; j < 6; j++) {
          const particleAngle = angle + (j - 3) * 0.3;
          const particleDistance = this.radius * (0.5 + j * 0.1);
          const particle = scene.add.circle(
            centerX + Math.cos(particleAngle) * particleDistance,
            centerY + Math.sin(particleAngle) * particleDistance,
            3, slashColor, 0.9
          );
          particle.setDepth(101);

          scene.tweens.add({
            targets: particle,
            x: centerX + Math.cos(particleAngle) * (particleDistance + 40),
            y: centerY + Math.sin(particleAngle) * (particleDistance + 40),
            alpha: 0,
            duration: 400,
            onComplete: () => particle.destroy()
          });
        }

        scene.tweens.add({
          targets: slash,
          alpha: 0,
          scaleX: 1.5,
          duration: 400,
          onComplete: () => slash.destroy()
        });
      });
    }

    // ì¤‘ì•™ íšŒì „ íš¨ê³¼
    const spinEffect = scene.add.circle(centerX, centerY, 30, slashColor, 0.5);
    spinEffect.setDepth(99);
    scene.tweens.add({
      targets: spinEffect,
      angle: 360,
      scale: 2,
      alpha: 0,
      duration: 600,
      onComplete: () => spinEffect.destroy()
    });

    // í”¼í•´ ì ìš© (ì•½ê°„ì˜ ì§€ì—° í›„)
    scene.time.delayedCall(200, () => {
      const monsters = scene.monsters.getChildren();
      const baseDamage = Math.floor(caster.stats.attack * this.damageMultiplier + this.damage);
      const comboMultiplier = caster.getComboMultiplier ? caster.getComboMultiplier() : 1.0;
      const totalDamage = Math.floor(baseDamage * comboMultiplier);

      monsters.forEach(monster => {
        const distance = Phaser.Math.Distance.Between(centerX, centerY, monster.x, monster.y);
        if (distance <= this.radius && !monster.isDead) {
          const result = monster.takeDamage(totalDamage, caster);
          scene.showDamageText(monster.x, monster.y - 30, result.damage, result.isCrit, result.isEvaded);

          // ì½¤ë³´ ì¦ê°€
          if (!result.isEvaded && caster.increaseCombo) {
            caster.increaseCombo();
          }

          // ë„‰ë°± ì ìš©
          if (!result.isEvaded && this.knockbackPower > 0) {
            const knockbackSource = { x: centerX, y: centerY };
            monster.applyKnockback(this.knockbackPower, 300, knockbackSource);
          }
        }
      });
    });
  }

  executeGenericAOE(scene, caster, centerX, centerY) {
    // ì¼ë°˜ AOE ìŠ¤í‚¬ (ê¸°ì¡´ ë¡œì§)
    const effect = scene.add.circle(centerX, centerY, this.radius, 0xFFFF00, 0.3);
    effect.setDepth(50);
    scene.tweens.add({
      targets: effect,
      alpha: 0,
      scale: 1.2,
      duration: 500,
      onComplete: () => effect.destroy()
    });

    // ë²”ìœ„ ë‚´ ëª¨ë“  ëª¬ìŠ¤í„° ëŒ€ë¯¸ì§€
    const monsters = scene.monsters.getChildren();
    const baseDamage = Math.floor(caster.stats.attack * this.damageMultiplier + this.damage);
    const comboMultiplier = caster.getComboMultiplier ? caster.getComboMultiplier() : 1.0;
    const totalDamage = Math.floor(baseDamage * comboMultiplier);

    monsters.forEach(monster => {
      const distance = Phaser.Math.Distance.Between(centerX, centerY, monster.x, monster.y);
      if (distance <= this.radius && !monster.isDead) {
        const result = monster.takeDamage(totalDamage, caster);
        scene.showDamageText(monster.x, monster.y - 30, result.damage, result.isCrit, result.isEvaded);

        // ì½¤ë³´ ì¦ê°€
        if (!result.isEvaded && caster.increaseCombo) {
          caster.increaseCombo();
        }

        // ë„‰ë°± ì ìš©
        if (!result.isEvaded && this.knockbackPower > 0) {
          const knockbackSource = { x: centerX, y: centerY };
          monster.applyKnockback(this.knockbackPower, 300, knockbackSource);
        }
      }
    });
  }

}

/**
 * RangedSkill - ì›ê±°ë¦¬ ìŠ¤í‚¬ (íŒŒë©¸ì˜ ì¼ê²©)
 */
export class RangedSkill extends Skill {
  execute(caster, target) {
    const scene = caster.scene;

    // íŒŒë©¸ì˜ ì¼ê²© ìŠ¤í‚¬ì¸ ê²½ìš° (warrior_skill_4)
    if (this.id === 'warrior_skill_4') {
      this.executeDoomStrike(scene, caster, target);
    } else {
      // ì¼ë°˜ ì›ê±°ë¦¬ ìŠ¤í‚¬
      this.executeGenericRanged(scene, caster, target);
    }
  }

  executeDoomStrike(scene, caster, target) {
    // íŒŒë©¸ì˜ ì¼ê²©: ê°•ë ¥í•œ ì¶©ê²©íŒŒ íš¨ê³¼
    const startX = caster.x;
    const startY = caster.y;
    const targetX = target.x;
    const targetY = target.y;
    const strikeColor = 0xFF4500;

    // ì¶©ê²©íŒŒ ë¼ì¸
    const shockwave = scene.add.rectangle(
      startX, startY, 20, 60, strikeColor, 0.9
    );
    shockwave.setDepth(100);
    shockwave.setRotation(Phaser.Math.Angle.Between(startX, startY, targetX, targetY));

    // ì¶©ê²©íŒŒ ì´ë™ ì• ë‹ˆë©”ì´ì…˜
    scene.tweens.add({
      targets: shockwave,
      x: targetX,
      y: targetY,
      scaleX: 3,
      alpha: 0,
      duration: 300,
      onComplete: () => shockwave.destroy()
    });

    // ë‹¤ì¤‘ ì¶©ê²©íŒŒ íŒŒí‹°í´
    for (let i = 0; i < 12; i++) {
      scene.time.delayedCall(i * 20, () => {
        const angle = Phaser.Math.Angle.Between(startX, startY, targetX, targetY) + (Math.random() - 0.5) * 0.8;
        const distance = 50 + Math.random() * 100;
        const particleX = startX + Math.cos(angle) * distance;
        const particleY = startY + Math.sin(angle) * distance;

        const particle = scene.add.circle(particleX, particleY, 4 + Math.random() * 4, strikeColor, 0.8);
        particle.setDepth(101);

        scene.tweens.add({
          targets: particle,
          x: targetX + (Math.random() - 0.5) * 80,
          y: targetY + (Math.random() - 0.5) * 80,
          alpha: 0,
          scale: 2,
          duration: 400,
          onComplete: () => particle.destroy()
        });
      });
    }

    // íƒ€ê²Ÿ ì£¼ë³€ í­ë°œ íš¨ê³¼
    scene.time.delayedCall(250, () => {
      const explosion = scene.add.circle(targetX, targetY, 40, strikeColor, 0.6);
      explosion.setDepth(99);
      scene.tweens.add({
        targets: explosion,
        scale: 2.5,
        alpha: 0,
        duration: 500,
        onComplete: () => explosion.destroy()
      });

      // í­ë°œ íŒŒí‹°í´
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const distance = 30;
        const particle = scene.add.circle(
          targetX + Math.cos(angle) * distance,
          targetY + Math.sin(angle) * distance,
          2, strikeColor, 0.9
        );
        particle.setDepth(102);

        scene.tweens.add({
          targets: particle,
          x: targetX + Math.cos(angle) * (distance + 60),
          y: targetY + Math.sin(angle) * (distance + 60),
          alpha: 0,
          duration: 600,
          onComplete: () => particle.destroy()
        });
      }
    });

    // í”¼í•´ ì ìš©
    scene.time.delayedCall(300, () => {
      if (!target.isDead) {
        const baseDamage = Math.floor(caster.stats.attack * this.damageMultiplier + this.damage);
        const comboMultiplier = caster.getComboMultiplier ? caster.getComboMultiplier() : 1.0;
        const totalDamage = Math.floor(baseDamage * comboMultiplier);

        const result = target.takeDamage(totalDamage, caster);
        scene.showDamageText(target.x, target.y - 30, result.damage, result.isCrit, result.isEvaded);

        // ì½¤ë³´ ì¦ê°€
        if (!result.isEvaded && caster.increaseCombo) {
          caster.increaseCombo();
        }

        // ê°•ë ¥í•œ ë„‰ë°± ì ìš©
        if (!result.isEvaded && this.knockbackPower > 0) {
          const knockbackSource = { x: caster.x, y: caster.y };
          target.applyKnockback(this.knockbackPower * 1.5, 400, knockbackSource);
        }
      }
    });
  }

  executeGenericRanged(scene, caster, target) {
    // ì¼ë°˜ ì›ê±°ë¦¬ ìŠ¤í‚¬ (ê¸°ì¡´ ë¡œì§)
    const projectile = scene.add.circle(caster.x, caster.y, 8, 0xFF0000, 0.8);
    projectile.setDepth(50);

    scene.tweens.add({
      targets: projectile,
      x: target.x,
      y: target.y,
      duration: 300,
      onComplete: () => {
        projectile.destroy();

        if (!target.isDead) {
          const baseDamage = Math.floor(caster.stats.attack * this.damageMultiplier + this.damage);
          const comboMultiplier = caster.getComboMultiplier ? caster.getComboMultiplier() : 1.0;
          const totalDamage = Math.floor(baseDamage * comboMultiplier);

          const result = target.takeDamage(totalDamage, caster);
          scene.showDamageText(target.x, target.y - 30, result.damage, result.isCrit, result.isEvaded);

          // ì½¤ë³´ ì¦ê°€
          if (!result.isEvaded && caster.increaseCombo) {
            caster.increaseCombo();
          }

          // ë„‰ë°± ì ìš©
          if (!result.isEvaded && this.knockbackPower > 0) {
            const knockbackSource = { x: caster.x, y: caster.y };
            target.applyKnockback(this.knockbackPower, 300, knockbackSource);
          }
        }
      }
    });
  }